import queue              # потокобезопасная очередь для передачи данных между потоками (клиенты → сервер).
import time               # для пауз между отправкой запросов, чтобы эмулировать реальные задержки
import threading          # нужен для запуска каждого клиента в отдельном потоке
from server import TaskServer
from client import ClientThread

def main():
    """
    Точка входа в демонстрацию: создаёт очередь, запускает сервер и клиентов,
    ждёт завершения клиентов, дождётся обработки всех запросов и корректно
    завершает сервер.

    Steps:
    1. Создаёт `queue.Queue()`.
    2. Создаёт и стартует `TaskServer`.
    3. Формирует сценарии `actions` для каждого клиента.
    4. Создаёт и стартует `ClientThread` для каждого сценария.
    5. Дожидается завершения клиентов (`join()`), затем опустошения очереди.
    6. Останавливает сервер и завершает программу.

    Важно: сначала дождаться, что клиенты отправили все запросы (join на клиентах),
    а затем подождать, пока очередь не опустеет, прежде чем останавливать сервер,
    чтобы не потерять необработанные запросы.
    """

    q = queue.Queue()       # очередь q для передачи задач от клиентов серверу
    server = TaskServer(q)  # сервер server, передаём ему эту очередь
    server.start()          # Запускаем сервер в отдельном потоке (server.start())

    # демонстрация всех трёх задач
    # список действий для первого клиента, где каждое действие — это словарь
    actions1 = [
        {'task': 'common', 'generate': True, 'params': {'len_a': 5, 'len_b': 5}},
        {'task': 'process', 'generate': True, 'params': {'len_a': 5, 'len_b': 5}}
    ]
    # список действий для второго клиента, где каждое действие — это словарь
    actions2 = [
        {'task': 'compute', 'generate': True, 'params': {'len': 4}},
        {'task': 'common', 'generate': True, 'params': {'len_a': 6, 'len_b': 6}}
    ]
    # список действий для третьего клиента, где каждое действие — это словарь
    actions3 = [
        {'task': 'process', 'generate': True, 'params': {'len_a': 4, 'len_b': 4}},
        {'task': 'compute', 'generate': True, 'params': {'len': 3}},
        {'task': 'common', 'generate': True, 'params': {'len_a': 5, 'len_b': 5}}
    ]
    # Показывает, что клиенты могут выполнять несколько разных задач^

    # объекты клиентов (читаемое имя, очередь, список действий), отправление запросов
    client1 = ClientThread("Клиент1", q, actions1)
    client2 = ClientThread("Клиент2", q, actions2)
    client3 = ClientThread("Клиент3", q, actions3)

    # Собираем всех клиентов в список
    clients = [client1, client2, client3]
    for c in clients: #  каждый клиент в отдельном потоке (start()), генерируют и отправляют задачи в очередь сервера
        c.start()

    print(f"\nЗапущено клиентов: {len(clients)}")
    print(f"Всего активных потоков: {threading.active_count()}\n")
    print("Наблюдайте за параллельной работой клиентов!\n")

    # дождёмся завершения клиентов (они асинхронно отправили все запросы)
    for c in clients:
        c.join() # блокирует выполнение main, пока клиентский поток не завершится

    # даём серверу время обработать всё (пока очередь не опустеет)
    while not q.empty():
        time.sleep(0.2)

    # чуть подождём, чтобы сервер напечатал завершающие строки результатов
    time.sleep(1.0)

    # останавливаем сервер, флаг running = False
    server.stop()
    server.join(timeout=2.0) # ждем заверешение серверного потока

if __name__ == "__main__":
    main()
